<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh" xml:lang="zh">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<link rel="stylesheet" type="text/css" href="learn-vi.css" />
	<title>VIMå­¦ä¹ ç¬”è®°  ()</title>
</head>
<body>
	<h1>VIMå­¦ä¹ ç¬”è®°  ()</h1>
    <p><a href="http://ctags.sourceforge.net/" title="ctags">Ctags</a></p>

<h2 id="what-is-ctags"><a class="anchor" aria-hidden="true" href="#what-is-ctags">ğŸ”—</a>What is ctags?</h2>
http://ctags.sourceforge.net/languages.html
<p>Ctags is a tool that extracts important constructs from the code youâ€™re working
on. If youâ€™re coding in ruby, itâ€™ll find methods, classes and modules. With
vimscript, it pulls out functions, commands and mappings. The extracted data is
dumped in a file called â€œtagsâ€ by default, which has a single item per line â€“
a â€œtagâ€. Depending on the command-line flags and the programming language, you
could get a lot of information out of these. For example, with C++ and Java,
ctags can save the inheritance chain for a class. A text editor can then easily
use that for code navigation and completion.</p>

<h2 id="installation-and-simplest-use-case"><a class="anchor" aria-hidden="true" href="#installation-and-simplest-use-case">ğŸ”—</a>Installation and simplest use case</h2>

<p>The actual program is called â€œExuberant ctagsâ€, since itâ€™s a rewrite of the original one.</p>

<ul>
  <li>å¯¹äºMac<code class="highlighter-rouge">brew
install ctags</code> or <code class="highlighter-rouge">port install ctags</code>.</li>
  <li>On Linux, Iâ€™ve yet to see a package manager that doesnâ€™t provide ctags.</li>
  <li>On Windows, just download the binary from
<a href="http://ctags.sourceforge.net/">the homepage</a> choco install ctags.</li>
</ul>

<p>Assuming the executable is in your <code class="highlighter-rouge">PATH</code> (it might not be if youâ€™re running
Windows), you can simply go to a directory with some code and run:</p>
	<p>ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤ï¼Œå¯ä»¥é’ˆå¯¹æŒ‡å®šæ–‡ä»¶ç”Ÿæˆtagsæ–‡ä»¶ï¼š</p>
	<p style="text-indent:2em"><code class="inset">:!ctags HTML.vim</code></p>
	<p>ä½ ä¹Ÿå¯ä»¥é’ˆå¯¹å½“å‰ç›®å½•åŠå…¶å­ç›®å½•ä¸­çš„æ‰€æœ‰æ–‡ä»¶ç”Ÿæˆtagsæ–‡ä»¶ï¼š</p>
	<p style="text-indent:2em"><code class="inset">:!ctags -R .</code></p>

	<p>ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤ï¼Œå¯ä»¥ç›´æ¥è·³è½¬åˆ°å®šä¹‰å‡½æ•°çš„ä½ç½®ï¼š</p>
	<p style="text-indent:2em"><code class="inset">:tag <var>name</var></code></p>
	<p>åœ¨å¸¸è§„æ¨¡å¼ä¸‹ï¼Œä½¿ç”¨<kbd>Ctrl-]</kbd>å¿«æ·é”®ï¼Œå°†æŸ¥æ‰¾å…‰æ ‡ä¸‹çš„æ ‡ç­¾ï¼ˆæ¯”å¦‚å‡½æ•°æˆ–å®ç­‰ï¼‰ï¼Œå¹¶è·³è½¬åˆ°å®šä¹‰è¯¥æ ‡ç­¾çš„ä½ç½®ï¼š</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Foo</span>
  <span class="k">def</span> <span class="nf">bar</span>
    <span class="s2">"baz"</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="no">Foo</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">bar</span>
</code></pre></div></div>

<p>If the cursor is on <code class="highlighter-rouge">Foo</code> at the <code class="highlighter-rouge">Foo.new.bar</code> line and you type <code class="highlighter-rouge">&lt;C-]&gt;</code>, vim
will jump on the <code class="highlighter-rouge">class Foo</code> line. This works across files as well. To get back
to where you followed something, just type <code class="highlighter-rouge">&lt;C-t&gt;</code> in normal mode. Using these
two mappings, you can navigate your entire project pretty easily. Note that
itâ€™s extremely fast, even if you have a large tag file. Thatâ€™s because the tags
are sorted and vim uses a binary search to quickly locate them. Itâ€™s simple and
highly effective.</p>

<h2 id="multiple-matches"><a class="anchor" aria-hidden="true" href="#multiple-matches">ğŸ”—</a>Multiple matches</h2>

<p>If you have multiple definitions for a tag, the default <code class="highlighter-rouge">&lt;C-]&gt;</code> behavior is to
drop you off at the first one it finds. By default, vim gives more priority to
tags in the current file, which is often what you want. While doing that,
youâ€™ll also be shown a message:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tag 1 of x or more
</code></pre></div></div>

<p>There are various ways to jump through the rest of the matches:</p>

<ul>
  <li><code class="highlighter-rouge">:tnext</code> and <code class="highlighter-rouge">:tprev</code> will send you to the next and previous tag in the
list, respectively.</li>
  <li><code class="highlighter-rouge">:tselect</code> will display the tag list and let you choose one with a number.</li>
  <li><code class="highlighter-rouge">:ltag</code> will load the tags into the location list window. You can then view
that window by executing <code class="highlighter-rouge">:lopen</code>.</li>
</ul>
<p>These commands will also accept regular expressions, so, for example, <code class="inline">:tag /^asserts_*</code> would find all tags that start with â€˜asserts_â€™. By default vim will
jump to the first result, but a number of commands can be used to sort through
the list of tags:</p>
<ul>
<li><code class="inline">:ts</code> or <code class="inline">:tselect</code> shows the list
</li>
<li><code class="inline">:tn</code> or <code class="inline">:tnext</code> goes to the next tag in that list
</li>
<li><code class="inline">:tp</code> or <code class="inline">:tprev</code> goes to the previous tag in that list
</li>
<li><code class="inline">:tf</code> or <code class="inline">:tfirst</code> goes to the first tag of the list
</li>
<li><code class="inline">:tl</code> or <code class="inline">:tlast</code> goes to the last tag of the list
</li>
</ul>
<p>To show the tags youâ€™ve traversed since you opened vim, run <code class="inline">:tags</code>.</p>
<p>For an easier time, you could always create some shortcuts. For example, you
could follow the convention of the
<a href="http://www.vim.org/scripts/script.php?script_id=1590">unimpaired.vim</a>
plugin and map <code class="highlighter-rouge">]t</code> for <code class="highlighter-rouge">:tnext</code> and <code class="highlighter-rouge">[t</code> for <code class="highlighter-rouge">:tprev.</code></p>

<h2 id="dynamic-tags-and-autotag"><a class="anchor" aria-hidden="true" href="#dynamic-tags-and-autotag">ğŸ”—</a>Dynamic tags and autotag</h2>

<p>Iâ€™m going to call the tags generated for your code â€œdynamicâ€, since youâ€™re
probably constantly making changes there. So, what happens when the tags are no
longer correct? While you could regularly invoke ctags on the working
directory, thatâ€™s going to get annoying pretty fast. Thankfully, the tool has
an <code class="highlighter-rouge">-a</code> flag that makes it append to a tag file instead of overwriting it. That
way, you can update the tags very quickly every time a file changes. With vimâ€™s
autocommands, this could work like this:</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code>autocmd <span class="nb">BufWritePost</span> *
<span class="se">      \</span> <span class="k">if</span> filereadable<span class="p">(</span><span class="s1">'tags'</span><span class="p">)</span> <span class="p">|</span>
<span class="se">      \</span>   <span class="k">call</span> system<span class="p">(</span><span class="s1">'ctags -a '</span><span class="p">.</span>expand<span class="p">(</span><span class="s1">'%'</span><span class="p">))</span> <span class="p">|</span>
<span class="se">      \</span> <span class="k">endif</span>
</code></pre></div></div>

<p>Unfortunately, thereâ€™s an issue with this approach. Ctags will only add new
tags, it wonâ€™t remove ones that are no longer present. If you delete a
function, it will still appear in the tag file.</p>

<p>Thatâ€™s where the
<a href="http://www.vim.org/scripts/script.php?script_id=1343">autotag.vim</a>
plugin comes in. Whenever you save a file, it deletes all of its entries and
invokes ctags in append mode. Iâ€™ve been using it for a long time and I havenâ€™t
noticed any overhead at all, even on Windows boxes. Unfortunately, your vim
build needs to have python support to use it. Even if it doesnâ€™t, though, no
errors are raised, which is nice if you use the same vimfiles across different
vim builds like I do.</p>

<h2 id="static-tags"><a class="anchor" aria-hidden="true" href="#static-tags">ğŸ”—</a>Static tags</h2>

<p>Another way you could use ctags is to index libraries that your project uses,
assuming you have their source locally. For example, until recently, I would
checkout the rails source code at <code class="highlighter-rouge">~/src/rails</code>, run ctags on it and save the
resulting file as <code class="highlighter-rouge">~/tags/rails.tags</code>. I use the nifty
<a href="http://www.vim.org/scripts/script.php?script_id=2719">Proj plugin</a>
to
source project-specific vimfiles, so I just have to add it to the
<a href="http://vimdoc.sourceforge.net/htmldoc/options.html#%27tags%27">â€˜tagsâ€™</a>
option:</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">set</span> <span class="k">tags</span><span class="p">+=~</span><span class="sr">/tags/</span>rails<span class="p">.</span><span class="k">tags</span>
</code></pre></div></div>

<p>This allows me to easily jump to a definition of a method within the framework
itself. Since rails is pretty well commented, I donâ€™t have to google for method
signatures, at least.</p>

<p>A better approach I eventually discovered was generating tags for <em>all gems</em> I
was using. Of course, I canâ€™t build an index of every single gem on my system.
There are different versions installed side-by-side and Iâ€™d get a whole lot of
duplication (if nothing else). But since bundler made its way into ruby, the
Gemfile always contains a nice snapshot of all gems your particular application
is using. Thankfully, we donâ€™t have to parse the actual file for that.
<a href="https://gist.github.com/893236">This little ruby snippet</a>
taps into bundlerâ€™s API to retrieve the gem locations and builds the tag file:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'bundler'</span>

<span class="n">paths</span> <span class="o">=</span> <span class="no">Bundler</span><span class="p">.</span><span class="nf">load</span><span class="p">.</span><span class="nf">specs</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:full_gem_path</span><span class="p">)</span>

<span class="nb">system</span><span class="p">(</span><span class="s2">"ctags -R -f gems.tags </span><span class="si">#{</span><span class="n">paths</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="s1">' '</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</code></pre></div></div>

<p>Even if this script is specific to ruby, the general approach could be used for
any kind of project. Just maintain a list of all libraries your application is
using, find them locally and run ctags on that.</p>

<h2 id="code-completion"><a class="anchor" aria-hidden="true" href="#code-completion">ğŸ”—</a>Code completion</h2>

<p>Vim has quite a few completion types to deal with different situations, but
<a href="http://vimdoc.sourceforge.net/htmldoc/insert.html#compl-omni">omnicompletion</a>,
which is meant to intelligently decide what to do, is just not very good
 for some languages. Thatâ€™s why, whenever I want to complete a method 
call or class name that I know is defined somewhere, I just use
<a href="http://vimdoc.sourceforge.net/htmldoc/insert.html#compl-tag">tag completion</a>:</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code>inoremap <span class="p">&lt;</span><span class="k">c</span><span class="p">-</span><span class="k">x</span><span class="p">&gt;&lt;</span><span class="k">c</span><span class="p">-]&gt;</span> <span class="p">&lt;</span><span class="k">c</span><span class="p">-]&gt;</span>
</code></pre></div></div>

<p>If youâ€™d like to have it appear automatically as you type, you could try the
<a href="http://www.vim.org/scripts/script.php?script_id=1879">Acp plugin</a>.
Itâ€™s fast and pretty customizable â€“ you can define the type of completion
youâ€™d like to use per filetype and depending on some specific condition.</p>

<h2 id="accessing-tag-data-in-vimscript"><a class="anchor" aria-hidden="true" href="#accessing-tag-data-in-vimscript">ğŸ”—</a>Accessing tag data in vimscript</h2>

<p>If youâ€™d like to use the tags for your own custom needs, vim provides a
straightforward way to do that through the
<a href="http://vimdoc.sourceforge.net/htmldoc/eval.html#taglist\(\)">taglist</a>
function. Itâ€™s called with a regular expression and it will return all the data
from the matching tags in the form of a list of dictionaries. An example of
what you could do with it is the following command, which finds function
definitions:</p>

<div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code>command<span class="p">!</span> <span class="p">-</span>nargs<span class="p">=</span><span class="m">1</span> Function <span class="k">call</span> <span class="nv">s:Function</span><span class="p">(&lt;</span><span class="k">f</span><span class="p">-</span>args<span class="p">&gt;)</span>
<span class="k">function</span><span class="p">!</span> <span class="nv">s:Function</span><span class="p">(</span>name<span class="p">)</span>
  <span class="c">" Retrieve tags of the 'f' kind</span>
  <span class="k">let</span> <span class="k">tags</span> <span class="p">=</span> taglist<span class="p">(</span><span class="s1">'^'</span><span class="p">.</span><span class="nv">a:name</span><span class="p">)</span>
  <span class="k">let</span> <span class="k">tags</span> <span class="p">=</span> <span class="k">filter</span><span class="p">(</span><span class="k">tags</span><span class="p">,</span> <span class="s1">'v:val["kind"] == "f"'</span><span class="p">)</span>

  <span class="c">" Prepare them for inserting in the quickfix window</span>
  <span class="k">let</span> qf_taglist <span class="p">=</span> <span class="p">[]</span>
  <span class="k">for</span> entry <span class="k">in</span> <span class="k">tags</span>
    <span class="k">call</span> add<span class="p">(</span>qf_taglist<span class="p">,</span> <span class="p">{</span>
<span class="se">          \</span> <span class="s1">'pattern'</span><span class="p">:</span>  entry<span class="p">[</span><span class="s1">'cmd'</span><span class="p">],</span>
<span class="se">          \</span> <span class="s1">'filename'</span><span class="p">:</span> entry<span class="p">[</span><span class="s1">'filename'</span><span class="p">],</span>
<span class="se">          \</span> <span class="p">})</span>
  <span class="k">endfor</span>

  <span class="c">" Place the tags in the quickfix window, if possible</span>
  <span class="k">if</span> len<span class="p">(</span>qf_taglist<span class="p">)</span> <span class="p">&gt;</span> <span class="m">0</span>
    <span class="k">call</span> setqflist<span class="p">(</span>qf_taglist<span class="p">)</span>
    <span class="k">copen</span>
  <span class="k">else</span>
    echo <span class="s2">"No tags found for "</span><span class="p">.</span><span class="nv">a:name</span>
  <span class="k">endif</span>
<span class="k">endfunction</span>
</code></pre></div></div>

<p>Invoking <code class="highlighter-rouge">:Function foo</code> will look for functions in the tag file that start
with â€œfooâ€ and load them all in the
<a href="http://vimdoc.sourceforge.net/htmldoc/quickfix.html#quickfix">quickfix</a>
window. This could be even more useful with some tab-completion and itâ€™s also
not very portable across filetypes. It shouldnâ€™t be too difficult to generalize
it a bit, so I might devote a separate blog post for that when I get around to
doing it.</p>

<h2 id="summary"><a class="anchor" aria-hidden="true" href="#summary">ğŸ”—</a>Summary</h2>

<ul>
  <li>You can use ctags to index the code youâ€™re working on. The autotag plugin
can keep the tag file up to date, but you need a vim with python support
for that.</li>
  <li>Generating tags for any libraries youâ€™re using is even easier, since they
wonâ€™t be changing any time soon. A potential problem is figuring out a way
to add the extra tag files just where you need them.</li>
  <li>Tag completion can often be good enough when you canâ€™t remember an exact
name for a function or class.</li>
  <li>Accessing the tag data for your own hardcore customization needs is done
through the <code class="highlighter-rouge">taglist</code> function.</li>
</ul>

For more on this stuff, run <code class="inline">:help tags</code> and <code class="inline">:help CTRL-]</code>
https://vim.fandom.com/wiki/Browsing_programs_with_tags
å‡å¦‚æˆ‘ä»¬æ­£åœ¨çœ‹ä¸€ä¸ªç¨‹åºæ–‡ä»¶,ä½†æ˜¯å´ç¢°åˆ°ä¸€ä¸ªæˆ‘ä»¬å¹¶ä¸ç†è§£çš„å‡½æ•°è°ƒç”¨.æˆ‘ä»¬å¯ä»¥ç”¨å‘½ä»¤CTRL-]è·³è½¬åˆ°å‡½æ•°å®šä¹‰çš„åœ°æ–¹.ä½†æ˜¯è¿™æ ·åšå´æœ‰ä¸€ä¸ªé—®é¢˜,é‚£å°±å½“å‰çš„æ–‡ä»¶è¢«å‡½æ•°å®šä¹‰çš„å†…å®¹æ‰€æ›¿ä»£,æˆ‘ä»¬ä¹Ÿå°±ä¸å¯ä»¥ä»å±å¹•ä¸Šçœ‹åˆ°è¿™ä¸ªæ–‡ä»¶çš„å†…å®¹äº†.
è¿™ä¸ªé—®é¢˜çš„ä¸€ä¸ªè§£å†³åŠæ³•å°±æ˜¯æˆ‘ä»¬ä½¿ç”¨è¢«ç§°ä¸ºpreviewçš„ç‰¹æ®Šçª—å£.æˆ‘ä»¬å¯ä»¥é€šè¿‡æ‰§è¡Œä¸‹é¢çš„å‘½ä»¤æ¥æ‰“å¼€previewçš„ç‰¹æ®Šçª—å£,åœ¨è¿™ä¸ªçª—å£ä¸­æ˜¾ç¤ºå‡½æ•°å®šä¹‰çš„å†…å®¹:
:ptag function
å¦‚æœæˆ‘ä»¬å·²ç»æ‰“å¼€äº†ä¸€ä¸ªpreviewçª—å£,é‚£ä¹ˆä»–å°±ä¼šåˆ‡æ¢åˆ°å½“å‰æ­£åœ¨æŸ¥çœ‹çš„å‡½æ•°å®šä¹‰å†…å®¹.å¦‚æœæˆ‘ä»¬è¦å…³é—­è¿™ä¸ªçª—å£,æˆ‘ä»¬å¯ä»¥æ‰§è¡Œä¸‹é¢çš„å‘½ä»¤:
:pclose
å‘½ä»¤CTRL-Wzå’ŒZZä¹Ÿå¯ä»¥æœ‰å…³é—­è¿™ä¸ªçª—å£çš„ä½œç”¨.
åœ¨previewçª—å£ä¸­æˆ‘ä»¬æ‰§è¡Œä¸‹é¢çš„å‘½ä»¤æ¥å®Œæˆæˆ‘ä»¬çš„å·¥ä½œ:
:ppop        åœ¨è¿™ä¸ªçª—å£ä¸­æ‰§è¡Œä¸€ä¸ª:popå‘½ä»¤.
:ptselect identifier    æ‰“å¼€ä¸€ä¸ªæ–°çš„previewçª—å£å¹¶æ‰§è¡Œ:tselectå‘½ä»¤
:ptjump identifier    æ‰“å¼€ä¸€ä¸ªæ–°çš„previewçª—å£å¹¶æ‰§è¡Œ:ptjump å‘½ä»¤
:count ptnext        åœ¨è¿™ä¸ªçª—å£ä¸­æ‰§è¡Œ:count tnextå‘½ä»¤
:count ptprevious    åœ¨è¿™ä¸ªçª—å£ä¸­æ‰§è¡Œ:count ptpreviouså‘½ä»¤
:count ptrewind        åœ¨è¿™ä¸ªçª—å£ä¸­æ‰§è¡Œ:count ptrewindå‘½ä»¤
:ptlast            åœ¨è¿™ä¸ªçª—å£ä¸­æ‰§è¡Œ:ptlastå‘½ä»¤.
CTRL-W}            ä»¥å½“å‰å…‰æ ‡ä¸‹çš„å†…å®¹æ‰§è¡Œä¸€ä¸ª:ptagå‘½ä»¤
CTRL-Wg}        ä»¥å½“å‰å…‰æ ‡ä¸‹çš„å†…å®¹æ‰§è¡Œä¸€ä¸ª:ptjumpå‘½ä»¤
	<p style="text-indent:2em"><code class="inset"></code></p>



<	A more exotic example, to jump between the '=' and ';' in an
	assignment, useful for languages like C and Java: >
		:au FileType c,cpp,java set mps+==:;
	<p>matchpairsé€‰é¡¹ï¼Œç”¨æ¥æ§åˆ¶å“ªäº›å­—ç¬¦å¯ä»¥é€šè¿‡<code class="inset">%</code>å‘½ä»¤è¿›è¡ŒåŒ¹é…ã€‚æ­¤é€‰é¡¹çš„é»˜è®¤å€¼å¦‚ä¸‹ï¼š</p>
	<p style="text-indent:2em"><code class="inset">:set matchpairs=(:),{:},[:]</code></p>
	<p>ä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨å¼€æ‹¬å·&ldquo;(,{,[&rdquo;ä¸Šç‚¹å‡»<code class="inset">%</code>å‘½ä»¤ï¼Œé‚£ä¹ˆå°†è‡ªåŠ¨è·³è½¬åˆ°å¯¹åº”çš„é—­æ‹¬å·ä¸Š&ldquo;),},]&rdquo;ï¼›åŒç†ï¼Œåœ¨é—­æ‹¬å·ä¸Šç‚¹å‡»<code class="inset">%</code>å‘½ä»¤ï¼Œåˆ™å°†è·³è½¬å›åˆ°å¯¹åº”çš„å¼€æ‹¬å·ä¸Šï¼›åŒæ—¶ï¼ŒåŒ¹é…è·³è½¬ä¹Ÿä¼šæ­£ç¡®å¤„ç†æ‹¬å·åµŒå¥—çš„æƒ…å†µã€‚</p>
	<p>å¦‚æœéœ€è¦æ–°å¢åŒ¹é…ç±»å‹ï¼Œä¾‹å¦‚å¢åŠ å¯¹äºHTMLæ–‡ä»¶ä¸­çš„å°–æ‹¬å·çš„åŒ¹é…ï¼Œé‚£ä¹ˆå¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤ï¼š</p>
	<p style="text-indent:2em"><code class="inset">:set mps+=&lt;:&gt;</code></p>
è¿™ä¸ªå‘½ä»¤ä»…ä»…æ˜¯åŒ¹é…<>.å¦‚æœæˆ‘ä»¬è¦åŒæ—¶åŒ¹é…å…¶ä»–çš„å­—ç¬¦,æˆ‘ä»¬å¯ä»¥ç”¨ä¸‹é¢çš„å‘½ä»¤:
:set matchpairs=(:),{:},[:],<:>
	<p style="color:gray; font-size:0.6em"><a href="http://yyq123.github.io/learn-vim/images/matchit-vim-example.gif" title="matchit-vim-example"><img src="http://yyq123.github.io/learn-vim/images/matchit-vim-example.gif" alt="" /></a></br>Source: https://catonmat.net/vim-plugins-matchit-vim</p>
<p></p>
å¦‚æœæˆ‘ä»¬å¸Œæœ›æˆ‘ä»¬åœ¨è¾“å…¥æ‹¬å·æ—¶,å…‰æ ‡ä¼šè·³è½¬åˆ°ä¸å…¶åŒ¹é…çš„åœ°æ–¹è¿›è¡Œæ˜¾ç¤º,æˆ‘ä»¬å¯ä»¥æ‰§è¡Œä¸‹é¢çš„å‘½ä»¤æ¥åšåˆ°:
	<p style="text-indent:2em"><code class="inset">:set showmatch</code></p>

é€šå¸¸æƒ…å†µä¸‹è¿™ä¸ªè·³è½¬æŒç»­çš„æ—¶é—´ä¸º0.5ç§’(åŠç§’),æˆ‘ä»¬å¯ä»¥ç”¨matchtimeé€‰é¡¹æ¥æ§åˆ¶è¿™ä¸ªæ—¶é—´.ä¾‹å¦‚å¦‚æœæˆ‘ä»¬å¸Œæœ›è¿™ä¸ªæ—¶é—´æŒç»­1.5ç§’,æˆ‘ä»¬å¯ä»¥ç”¨ä¸‹é¢çš„å‘½ä»¤:
:set matchtime=15
åœ¨è¿™é‡Œæ˜¯ä»¥0.1ç§’ä¸ºå•ä½çš„.
<p></p>
æˆ‘ä»¬åœ¨Vimç¼–è¾‘å™¨è¿˜å¯ä»¥ç”¨å‘½ä»¤æ¥æŸ¥æ‰¾æœªåŒ¹é…çš„æ‹¬å·.å¦‚[{æŸ¥æ‰¾å‰ä¸€ä¸ªæœªåŒ¹é…çš„{,]{æŸ¥æ‰¾åä¸€ä¸ªæœªåŒ¹é…çš„{.[}æŸ¥æ‰¾å‰ä¸€ä¸ªæœªåŒ¹é…çš„},è€Œ]}æŸ¥æ‰¾åä¸€ä¸ªæœªåŒ¹é…çš„}.
])æŸ¥æ‰¾åä¸€ä¸ªæœªåŒ¹é…çš„),è€Œ[(æŸ¥æ‰¾å‰ä¸€ä¸ªæœªåŒ¹é…çš„(.[#æŸ¥æ‰¾å‰ä¸€ä¸ªæœªåŒ¹é…çš„#ifæˆ–è€…æ˜¯#else.è€Œ]#æŸ¥æ‰¾åä¸€ä¸ªæœªåŒ¹é…çš„åŒç±»æƒ…å†µ.
ä¸‹é¢çš„å‘½ä»¤å¯ä»¥ç§»åŠ¨ä¸€ä¸ªJavaæ–¹æ³•çš„å¼€å¤´æˆ–ç»“å°¾:
[m    å‘åæŸ¥æ‰¾ä¸€ä¸ªæ–¹æ³•çš„å¼€å¤´
[M    å‘åæŸ¥æ‰¾ä¸€ä¸ªæ–¹æ³•çš„ç»“å°¾
]m    å‘å‰æŸ¥æ‰¾ä¸€ä¸ªæ–¹æ³•çš„å¼€å¤´
]M    å‘å‰æŸ¥æ‰¾ä¸€ä¸ªæ–¹æ³•çš„ç»“å°¾
åœ¨Vimç¼–è¾‘å™¨è¿˜æä¾›äº†è®¸å¤šçš„ç§»åŠ¨å‘½ä»¤æ¥å¸®åŠ©ç¨‹åºäººå‘˜åœ¨ä»–ä»¬çš„ç¨‹åºæ–‡ä»¶ä¸­è¿›è¡Œæµè§ˆ.ä¸‹é¢çš„ä¸€äº›å‘½ä»¤å¯ä»¥æ‰¾åˆ°ä½äºç¬¬ä¸€åˆ—çš„{å’Œ}:
count[[        å‘åæŸ¥æ‰¾ä½äºç¬¬ä¸€åˆ—çš„å‰ä¸€ä¸ª{
count[]        å‘åæŸ¥æ‰¾ä½äºç¬¬ä¸€åˆ—çš„å‰ä¸€ä¸ª}
count]]        å‘å‰æŸ¥æ‰¾ä½äºç¬¬ä¸€åˆ—çš„åä¸€ä¸ª{
count][        å‘å‰æŸ¥æ‰¾ä½äºç¬¬ä¸€åˆ—çš„åä¸€ä¸ª}
å‘½ä»¤[/å’Œ[*å¯å‘åç§»åŠ¨ä»–å¯ä»¥æ‰¾åˆ°çš„ç¬¬ä¸€ä¸ªCæ³¨é‡Šçš„å¼€å§‹å¤„,è€Œ]/å’Œ]*å¯ä»¥å‘å‰ç§»åŠ¨ä»–å¯ä»¥æ‰¾åˆ°ä¸‹ä¸€ä¸ªCæ³¨é‡Šçš„ç»“æŸå¤„.
includeé€‰é¡¹å¯ä»¥ç”¨æ¥ä¸ºæˆ‘ä»¬ä½¿ç”¨å‘½ä»¤]CTRL-I,[CTRL-I,]d,[dåœ¨è¿™äº›æˆ‘ä»¬æ‰€åŒ…å«è¿›æ¥çš„æ–‡ä»¶ä¸­è¿›è¡ŒæŸ¥æ‰¾.è¿™ä¸ªé€‰é¡¹ä¹Ÿå¯ä»¥ä¸ºå‘½ä»¤:checkpathæ‰€ç”¨.
å‘½ä»¤[iç”¨æ¥æŸ¥æ‰¾å…‰æ ‡ä¸‹çš„å†…å®¹ç¬¬ä¸€æ¬¡å‡ºç°çš„åœ°æ–¹.æ³¨é‡Šçš„æ–‡æœ¬ä¼šè¢«å¿½ç•¥æ‰.
å‘½ä»¤]jç”¨æ¥æŸ¥æ‰¾å…‰æ ‡ä¸‹çš„å†…å®¹ä¸‹ä¸€æ¬¡å‡ºç°çš„åœ°æ–¹.æ³¨é‡Šçš„æ–‡æœ¬ä¼šè¢«å¿½ç•¥æ‰.
å‘½ä»¤[Iä¼šåˆ—å‡ºæ‰€æœ‰åŒ…å«å½“å‰å…‰æ ‡ä¸‹çš„å†…å®¹çš„å¥å­,å‘½ä»¤]Iä¸å…¶ç›¸ç±»ä¼¼,åªæ˜¯è¿™ä¸ªå‘½ä»¤æ˜¯ä»å½“å‰å…‰æ ‡å¤„å¼€å§‹.
:makeå‘½ä»¤ä¼šäº§ç”Ÿä¸€ä¸ªé”™è¯¯åˆ—è¡¨.Vimç¼–è¾‘å™¨ä¼šè®°ä½æˆ‘ä»¬å‰10æ¬¡:makeå‘½ä»¤å’Œ:grepå‘½ä»¤çš„æ‰§è¡Œç»“æœ.å¦‚æœæˆ‘ä»¬è¦åˆ°å‰ä¸€æ¬¡çš„é”™è¯¯åˆ—è¡¨,æˆ‘ä»¬å¯ä»¥ç”¨ä¸‹é¢çš„å‘½ä»¤:
:colder
å¦‚æœæˆ‘ä»¬è¦åˆ°ä¸€ä¸ªæ–°çš„é”™è¯¯åˆ—è¡¨,æˆ‘ä»¬å¯ä»¥ç”¨ä¸‹é¢çš„å‘½ä»¤:
:cnewer
å½“æˆ‘ä»¬æ‰§è¡Œ:makeå‘½ä»¤æ—¶æ‰€è¦æ‰§è¡Œçš„ç¨‹åºåç§°æ˜¯ç”±makeprgé€‰é¡¹æ¥å®šä¹‰çš„.åœ¨é€šå¸¸çš„æƒ…å†µä¸‹ä¼šè®¾ä¸ºmake,ä½†æ˜¯Visual C++çš„ç”¨æˆ·å¯ä»¥é€šè¿‡ä¸‹é¢çš„å‘½ä»¤å°†å…¶è®¾ä¸ºnmake:
:set makeprg=nmake
:makeå‘½ä»¤ä¼šé‡å®šå‘Makeçš„è¾“å‡ºåˆ°ä¸€ä¸ªé”™è¯¯æ–‡ä»¶.è¿™ä¸ªæ–‡ä»¶çš„åå­—æ˜¯ç”±makeefé€‰é¡¹æ¥æ§åˆ¶çš„.å¦‚æœè¿™ä¸ªé€‰é¡¹åŒ…å«æœ‰å­—ç¬¦##,å­—ç¬¦##å°±ä¼šè¢«ä¸“ä¸€çš„æ•°å­—æ‰€ä»£æ›¿.è¿™ä¸ªé€‰é¡¹é»˜è®¤çš„å€¼å–å†³äºæˆ‘ä»¬æ­£åœ¨ä½¿ç”¨çš„æ“ä½œç³»ç»Ÿ.é»˜è®¤çš„å€¼å¦‚ä¸‹:
Amiga        t:vim##.Err
UNIX        /tmp/vim##.err
Windows        vim##.err
æˆ‘ä»¬å¯ä»¥åœ¨å‘½ä»¤ä¸­åŒ…å«æŒ‡å®šçš„Vimå…³é”®å­—.%å­—ç¬¦å¯ä»¥æ‰©å±•å½“å‰æ–‡ä»¶çš„åå­—,æ‰€ä»¥æˆ‘ä»¬æ‰§è¡Œä¸‹é¢çš„å‘½ä»¤:
:set makeprg=make%
ç„¶åæˆ‘ä»¬æ‰§è¡Œå‘½ä»¤:
:make
ä»–å°±ä¼šæ‰§è¡Œä¸‹é¢çš„å‘½ä»¤:
$ make file.c
file.cå°±æ˜¯æˆ‘ä»¬æ­£åœ¨ç¼–è¾‘çš„æ–‡ä»¶çš„åå­—.è¿™ä¸ªå¹¶æ²¡æœ‰å¤ªå¤§çš„ç”¨å¤„,æ‰€ä»¥æˆ‘ä»¬å¯ä»¥é‡æ–°å®šä¹‰è¿™ä¸ªå‘½ä»¤å¹¶ä½¿ç”¨:r(root)çš„æƒé™:
:set makeprg=make%:r.o
è¿™æ ·æˆ‘ä»¬å°±ä¼šæ‰§è¡Œä¸‹é¢çš„å‘½ä»¤:
$ make file.o
é€‰é¡¹errorformatå¯ä»¥ç”¨æ¥æ§åˆ¶Vimå¦‚ä½•æ¥ç»„ç»‡é”™è¯¯æ–‡ä»¶ä»¥ä½¿å¾—ä»–å¯ä»¥çŸ¥é“æ–‡ä»¶åä»¥åŠé”™è¯¯å‘ç”Ÿçš„åœ°æ–¹.è¿™ä¸ªé€‰é¡¹çš„æ ¼å¼å¦‚ä¸‹:
:set errorformat={string},{string},{string}
è¿™é‡Œçš„å­—ç¬¦æ˜¯ç”±ç‰¹æ®Šå­—ç¬¦%æ‰€æŒ‡å‡ºçš„å…¸å‹çš„é”™è¯¯ä¿¡æ¯ç”¨æ¥æŒ‡æ˜ç‰¹æ®Šçš„æ“ä½œ(ä¸æ ‡å‡†Cå‡½æ•°scanfå¾ˆç›¸åƒ).è¿™äº›ç‰¹æ®Šçš„å­—ç¬¦å¦‚ä¸‹:
%f    æ–‡ä»¶å
%l    è¡Œå·
%c    åˆ—å·
%t    é”™è¯¯ç±»å‹(å•ä¸€å­—ç¬¦)
%n    é”™è¯¯è¡Œå·
%m    é”™è¯¯ä¿¡æ¯
%r    åŒ¹é…ä¸€è¡Œä¸­çš„å‰©ä½™
%*{char}åŒ¹é…å¹¶è·³è¿‡ç”±{char}æ‰€æŒ‡å®šçš„scanfè½¬æ¢
%%    å­—ç¬¦%
å½“æˆ‘ä»¬åœ¨ç¼–è¯‘ä¸€ä¸ªç¨‹åºçš„æ—¶å€™,æˆ‘ä»¬ä¹Ÿè®¸è¦åœ¨å‡ ä¸ªç›®å½•ä¸­è¿›è¡Œéå†.GNU makeç¨‹åºä¼šåœ¨å½“æˆ‘ä»¬è¿›å…¥ä¸€ä¸ªç›®å½•æˆ–æ˜¯ç¦»å¼€ä¸€ä¸ªç›®å½•æ—¶æ‰“å°å‡ºç›¸åº”çš„ä¿¡æ¯.
å¦‚æœè¦æ­£ç¡®çš„å¾—åˆ°æ–‡ä»¶å,Vimå°±è¦æ¸…æ¥šçš„çŸ¥é“è¿™äº›ç›®å½•çš„å˜åŒ–.ä¸‹é¢çš„ä¸€äº›é”™è¯¯æ ¼å¼ç”¨æ¥åœ¨ç›®å½•å‘ç”Ÿå˜åŒ–æ—¶å‘Šè¯‰Vimä¸€äº›ç›¸å…³çš„ä¿¡æ¯:
%D    å½“è¿›å…¥ä¸€ä¸ªç›®å½•æ—¶æ‰“å°å‡ºæŒ‡å®šçš„ä¿¡æ¯.å­—ç¬¦ä¸²çš„%fæŒ‡æ˜æˆ‘ä»¬æ‰€è¿›å…¥çš„ç›®å½•
%X    æŒ‡å®šç¦»å¼€ç›®å½•æ—¶çš„ä¿¡æ¯.å­—ç¬¦ä¸²ä¸­çš„%fæŒ‡æ˜äº†makeå·²ç”¨æ¯•çš„ç›®å½•.
ä¸€äº›ç¼–è¯‘å™¨,ä¾‹å¦‚GNU GCCç¼–è¯‘å™¨,ä¼šè¾“å…¥ä¸€äº›å†—é•¿çš„é”™è¯¯ä¿¡æ¯.å¦‚æœæˆ‘ä»¬æ­£åœ¨ä½¿ç”¨é»˜è®¤çš„errorformatå°±ä¼šå¯¼è‡´ä¸‰ç§é”™è¯¯ä¿¡æ¯.è¿™å®åœ¨æ˜¯å¤Ÿè®¨åŒçš„.ä½†æ˜¯å¹¸è¿çš„æ˜¯Vimç¼–è¾‘å™¨å¯ä»¥è¯†åˆ«å‡ºä¸åŒçš„é”™è¯¯ä¿¡æ¯.å¤„ç†ä¸åŒä¿¡æ¯çš„æ¨¡å¼ä»£ç å¦‚ä¸‹:
%A    å¼€å§‹å¤šè¡Œä¿¡æ¯
%E    å¼€å§‹å¤šè¡Œé”™è¯¯ä¿¡æ¯
%W    å¼€å§‹å¤šè¡Œè­¦å‘Šä¿¡æ¯
%C    è¿ç»­å¤šè¡Œä¿¡æ¯
%Z    ç»“æŸå¤šè¡Œä¿¡æ¯
%G    å…¨å±€.åªæœ‰åœ¨+æˆ–æ˜¯-è¿æ¥æ—¶æ‰æœ‰ç”¨
%O    å•è¡Œæ–‡ä»¶ä¿¡æ¯:é‡æ–°è¯»å…¥åŒ¹é…çš„éƒ¨åˆ†
%P    å•è¡Œæ–‡ä»¶ä¿¡æ¯:å°†%fæ–‡ä»¶å‹å…¥æ ˆ
%Q    å•è¡Œæ–‡ä»¶ä¿¡æ¯:å°†æœ€åä¸€ä¸ªæ–‡ä»¶å‹å‡ºæ ˆ
+æˆ–æ˜¯-å¯ä»¥æ”¾åœ¨ä»»ä½•å­—ç¬¦çš„å‰é¢,ä»è€Œç»„æˆä¸‹é¢çš„å†…å®¹:
%-letter    ä¸è¦åŒ…å«è¾“å‡ºä¸­çš„åŒ¹é…è¡Œ
%+letter    åŒ…å«%mé”™è¯¯å­—ç¬¦ä¸²çš„æ•´ä¸ªåŒ¹é…è¡Œ
åœ¨é€šå¸¸çš„æƒ…å†µä¸‹,æˆ‘ä»¬æ‰§è¡Œ:makeå‘½ä»¤å¹¶æœ‰é”™è¯¯å‘ç”Ÿ,Vimä¼šåœ¨å½“å‰çš„çª—å£ä¸­æ˜¾ç¤ºé”™è¯¯æ–‡ä»¶.å¦‚æœæˆ‘ä»¬é€šè¿‡è®¾ç½®switchbufé€‰é¡¹æ¥è¿›è¡Œçª—å£çš„åˆ†è£‚,Vimå°±ä¼šåœ¨ä¸€ä¸ªæ–°çš„çª—å£æ¥æ˜¾ç¤ºé”™è¯¯æ–‡ä»¶..#å’Œ%å­—ç¬¦ä¼šæ‰©å±•åˆ°å½“å‰æ–‡ä»¶åå’Œäº¤æ›¿æ–‡ä»¶å.è€Œå­—ç¬¦ä¸²$*å°†ä¼šè¢«:grepå‘½ä»¤çš„å‚æ•°æ‰€ä»£æ›¿.
ç¼–è¯‘æˆ–è€… grep çš„æ—¶å€™ï¼Œä¿¡æ¯è¾“å‡ºåˆ° Quickfixçª—å£ä¸­ï¼ŒæŒ‰å›è½¦å°±å®¹æ˜“æŠŠbufç»™åˆ‡æ¢èµ°ï¼Œä½¿ç”¨æ ‡ç­¾åè®¾ç½®ä¸‹é¢ä¸€é¡¹ï¼Œå³å¯æ›´æ”¹quickfixè¡Œä¸ºä¸ºï¼šå¦‚æœæœ‰å·²æ‰“å¼€æ–‡ä»¶ï¼Œå…ˆå¤ç”¨ï¼Œæ²¡æœ‰çš„è¯ä½¿ç”¨æ ‡ç­¾ï¼š
set switchbuf=useopen,usetab,newtab

åœ¨é€šå¸¸çš„æƒ…å†µä¸‹,Vimæ˜¯ä½¿ç”¨äºŒåˆ†æ³•è¿›è¡ŒæŸ¥æ‰¾æŒ‡å®šçš„æ ‡è®°åå­—.å¦‚æœä¸€ä¸ªæ ‡è®°æ–‡ä»¶æ˜¯æŒ‰åºæ’åˆ—çš„,è¿™æ ·çš„æ–¹æ³•å¯ä»¥æ˜¯å¾ˆå¿«é€Ÿçš„.å¦åˆ™çš„è¯æˆ‘ä»¬å¯ä»¥ä½¿ç”¨çº¿æ€§æŸ¥æ‰¾çš„æ–¹æ³•.å¦‚æœè¦å¼ºåˆ¶è¿›è¡Œçº¿æ€§æŸ¥æ‰¾,æˆ‘ä»¬å¯ä»¥ç”¨ä¸‹é¢çš„å‘½ä»¤;
:set notagbsearch
è¿™ä¸ªé€‰é¡¹ä¼šåœ¨æˆ‘ä»¬çš„æ ‡è®°æ–‡ä»¶ä¸æ˜¯æœ‰åºçš„æ—¶æœ‰ç”¨.
æœ‰ä¸€äº›ç³»ç»Ÿä¼šé™åˆ¶æˆ‘ä»¬åœ¨å‡½æ•°åä¸­æ‰€ä½¿ç”¨çš„å­—ç¬¦æ•°.å¦‚æœæˆ‘ä»¬è¦åœ¨Vimä¸­åŠ å…¥è¿™æ ·çš„é™åˆ¶,æˆ‘ä»¬å¯ä»¥é€šè¿‡è®¾ç½®taglengthé€‰é¡¹æ¥é™åˆ¶æˆ‘ä»¬å‡½æ•°åçš„æœ€å¤§é•¿åº¦.
æˆ‘ä»¬å¯ä»¥ç”¨tagsé€‰é¡¹æ¥æŒ‡å®šæ ‡è®°æ–‡ä»¶å.è¿™ä¸ªå¯ä»¥ç”¨æ¥æŒ‡å…¶ä»–ç›®å½•ä¸­çš„æ–‡ä»¶.å¦‚:
:set tags+=/home/oualline/tools/vim/tags
ä½†æ˜¯è¿™ä¼šå¸¦æ¥ä¸€äº›ä»¤äººè´¹è§£çš„åœ°æ–¹.æ˜¯æˆ‘ä»¬åœ¨å½“å‰ç›®å½•ä¸­å¯åŠ¨å¹¶å‘Šè¯‰ctagså°†æ ‡è®°æ–‡ä»¶æ”¾åœ¨ç›®å½•/home/oualline/tools/vimè¿˜æ˜¯æˆ‘ä»¬åœ¨å½“å‰çš„ç›®å½•æ‰§è¡Œäº†ctagså‘¢?ç°åœ¨çš„Vimç¼–è¾‘å™¨å·²ç»ç”¨å…¶ä»–çš„é€‰é¡¹æ¥è§£å†³äº†è¿™ä¸ªé—®é¢˜äº†.å¦‚æœæˆ‘ä»¬è¿›è¡Œä¸‹é¢çš„è®¾ç½®,æ‰€æœ‰çš„æ ‡è®°éƒ½ä¼šå’Œå«æœ‰æ ‡è®°æ–‡ä»¶çš„ç›®å½•æœ‰å…³ç³»:
:set tagrelative
å¦åˆ™çš„è¯,ä»–ä»¬ä¼šå’Œå½“å‰ç›®å½•æœ‰å…³ç³».
å¦‚æœæˆ‘ä»¬è®¾ç½®äº†tagstacké€‰é¡¹,é‚£ä¹ˆ:tagå‘½ä»¤å’Œ:tjumpå‘½ä»¤å°±ä¼šå»ºç«‹ä¸€ä¸ªæ ‡è®°æ ˆ.å¦åˆ™æ˜¯ä¸ä¼šä¿æŒæ ˆçš„.
	<p><a href="https://yyq123.github.io/learn-vim/images/.png" title=""><img src="https://yyq123.github.io/learn-vim/images/.png" alt="" width="500" height="" /></a></p>
	<p style="color:gray; font-size:0.6em"><a href="http://yyq123.github.io/learn-vim/images/.png" title=""><img src="http://yyq123.github.io/learn-vim/images/.png" alt="" /></a></br>Source: medium.com/free-code-camp</p>


	<p></p>

	<p></p>
	<p style="text-indent:2em"><code class="inset"></code></p>

	<p><a href="https://yyq123.github.io/learn-vim/images/.png" title=""><img src="https://yyq123.github.io/learn-vim/images/.png" alt="" width="500" height="" /></a></p>

	<table summary="Commands" border="2" frame="hsides" rules="all" cellspacing="0" cellpadding="3">
		<caption>å‘½ä»¤å°ç»“</caption>
		<tr><td><code class="inset">:</code></td><td rowspan="2"></td></tr>
		<tr><td><code class="inset">:</code></td></tr>
		<tr><td><code class="inset">:</code></td><td></td></tr>
		<tr><td><code class="inset">:</code></td><td></td></tr>
		<tr><td><code class="inset">:</code></td><td></td></tr>
	</table>
&ldquo;&rdquo;

	<p style="border-top:1px solid lightgray"><span style="float:right">Ver: 2.0&nbsp;|&nbsp;<a href="mailto:yyq123@gmail.com">YYQ</a></span><span>&lt;<a title="" href="http://yyq123.github.io/learn-vim/.html">ä¸Šä¸€ç¯‡</a>&nbsp;|<a title="ç¬”è®°åˆ—è¡¨" href="http://yyq123.github.com/learn-vim/learn-vi-00-00-TOC.html">&nbsp;ç›®å½•&nbsp;</a>|&nbsp;<a title="" href="http://yyq123.github.io/learn-vim/.html">ä¸‹ä¸€ç¯‡</a>&gt;</span></p>

</body>
</html>
